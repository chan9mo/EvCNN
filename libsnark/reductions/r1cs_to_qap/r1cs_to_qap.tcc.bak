/** @file


 Implementation of interfaces for a R1CS-to-QAP reduction.

 See r1cs_to_qap.hpp .

 *****************************************************************************
 * @author     This file is part of libsnark, developed by SCIPR Lab
 *             and contributors (see AUTHORS).
 * @copyright  MIT license (see LICENSE file)
 *****************************************************************************/

#ifndef R1CS_TO_QAP_TCC_
#define R1CS_TO_QAP_TCC_

#include <libff/common/profiling.hpp>
#include <libff/common/utils.hpp>
#include <libfqfft/evaluation_domain/get_evaluation_domain.hpp>

namespace libsnark {

	/**
	 * Instance map for the R1CS-to-QAP reduction.
	 *
	 * Namely, given a R1CS constraint system cs, construct a QAP instance for which:
	 *   A := (A_0(z),A_1(z),...,A_m(z))
	 *   B := (B_0(z),B_1(z),...,B_m(z))
	 *   C := (C_0(z),C_1(z),...,C_m(z))
	 * where
	 *   m = number of variables of the QAP
	 * and
	 *   each A_i,B_i,C_i is expressed in the Lagrange basis.
	 */
	template<typename FieldT>
		 qap_instance<FieldT> r1cs_to_qap_instance_map(const r1cs_constraint_system<FieldT> &cs)
	{
		libff::enter_block("Call to r1cs_to_qap_instance_map");

		const std::shared_ptr<libfqfft::evaluation_domain<FieldT> > domain = libfqfft::get_evaluation_domain<FieldT>(cs.num_constraints() + cs.num_inputs() + 1);
		//const std::shared_ptr<libfqfft::evaluation_domain<FieldT> > domain = libfqfft::get_evaluation_domain<FieldT>(cs.num_constraints() + cs.num_inputs() + 1 + (cs.num_convol_outputs(0)));//*(cs.num_convol()));

		std::vector<std::map<size_t, FieldT> > A_in_Lagrange_basis(cs.num_variables()+1);
		std::vector<std::map<size_t, FieldT> > B_in_Lagrange_basis(cs.num_variables()+1);
		std::vector<std::map<size_t, FieldT> > C_in_Lagrange_basis(cs.num_variables()+1);

		libff::enter_block("Compute polynomials A, B, C in Lagrange basis");
		/**
		 * add and process the constraints
		 *     input_i * 0 = 0
		 * to ensure soundness of input consistency
		 */
		for (size_t i = 0; i <= cs.num_inputs(); ++i)
		{
			A_in_Lagrange_basis[i][cs.num_constraints() + i] = FieldT::one();
		}

		size_t conv_index_a = 0;
		size_t conv_index_b = 0;
		size_t conv_index_c = 0;

		
		/* process all other constraints */
		for (size_t i = 0; i < cs.num_constraints(); ++i)
		{
			for (size_t j = 0; j < cs.constraints[i].a.terms.size(); ++j)
			{
				A_in_Lagrange_basis[cs.constraints[i].a.terms[j].index][i] +=
					cs.constraints[i].a.terms[j].coeff;
			}

			for (size_t j = 0; j < cs.constraints[i].b.terms.size(); ++j)
			{
				B_in_Lagrange_basis[cs.constraints[i].b.terms[j].index][i] +=
					cs.constraints[i].b.terms[j].coeff;
			}

			for (size_t j = 0; j < cs.constraints[i].c.terms.size(); ++j)
			{
				C_in_Lagrange_basis[cs.constraints[i].c.terms[j].index][i] +=
					cs.constraints[i].c.terms[j].coeff;
			}

			for(size_t j=0;j<cs.constraints[i].a1.terms.size();j++){
				///TODO change (j+1) to safe value like prime
				if(j==0) conv_index_a ++;
				for(size_t k=0;k<cs.num_convol_outputs();k++){
					A_in_Lagrange_basis[cs.constraints[i].a1.terms[j].index][i] +=
						(FieldT(j+1)^cs.constraints[i].a1.terms[j].coeff.as_ulong());
				}
			}
			for(size_t j=0;j<cs.constraints[i].b1.terms.size();j++){
				///TODO change (j+1) to safe value like prime
				if(j==0) conv_index_b ++;
				for(size_t k=0;k<cs.num_convol_outputs();k++){
					B_in_Lagrange_basis[cs.constraints[i].b1.terms[j].index][i] +=
						(FieldT(j+1)^cs.constraints[i].b1.terms[j].coeff.as_ulong());
				}
			}

			for(size_t j=0;j<cs.constraints[i].c1.terms.size();j++){
				///TODO change (j+1) to safe value like prime
				if(j==0) conv_index_c ++;
				for(size_t k=0;k<cs.num_convol_outputs();k++){
					C_in_Lagrange_basis[cs.constraints[i].c1.terms[j].index][i] +=
						(FieldT(j+1)^cs.constraints[i].c1.terms[j].coeff.as_ulong());
				}
			}
		}
		libff::leave_block("Compute polynomials A, B, C in Lagrange basis");

		libff::leave_block("Call to r1cs_to_qap_instance_map");

		return qap_instance<FieldT>(domain,
				cs.num_variables(),
				domain->m,
				cs.num_inputs(),
				std::move(A_in_Lagrange_basis),
				std::move(B_in_Lagrange_basis),
				std::move(C_in_Lagrange_basis));
	}

	/**
	 * Instance map for the R1CS-to-QAP reduction followed by evaluation of the resulting QAP instance.
	 *
	 * Namely, given a R1CS constraint system cs and a field element t, construct
	 * a QAP instance (evaluated at t) for which:
	 *   At := (A_0(t),A_1(t),...,A_m(t))
	 *   Bt := (B_0(t),B_1(t),...,B_m(t))
	 *   Ct := (C_0(t),C_1(t),...,C_m(t))
	 *   Ht := (1,t,t^2,...,t^n)
	 *   Zt := Z(t) = "vanishing polynomial of a certain set S, evaluated at t"
	 * where
	 *   m = number of variables of the QAP
	 *   n = degree of the QAP
	 */
	template<typename FieldT>
		qap_instance_evaluation<FieldT> r1cs_to_qap_instance_map_with_evaluation(const r1cs_constraint_system<FieldT> &cs,
				const FieldT &t)
		{



			libff::enter_block("Call to r1cs_to_qap_instance_map_with_evaluation");
			
			//const std::shared_ptr<libfqfft::evaluation_domain<FieldT> > domain = libfqfft::get_evaluation_domain<FieldT>(cs.num_constraints() + cs.num_inputs() + 1);
			size_t degree = cs.num_constraints() + cs.num_inputs() + 1;
			for(size_t i=0;i<cs.num_convol;i++){
				degree += (cs.num_convol_outputs(i))*(cs.num_convol_outputs2(i));
			}
			const std::shared_ptr<libfqfft::evaluation_domain<FieldT> > domain = libfqfft::get_evaluation_domain<FieldT>(degree);

			
			/*
			else{
				domain = libfqfft::get_evaluation_domain<FieldT>(cs.num_constraints() + cs.num_inputs() + 1 + (cs.num_convol_outputs())*(cs.num_convol()+1));
			}
			*/
			//std::cout<<"#constraint : "<< cs.num_constraints()<<"\t#input : "<< cs.num_inputs()<<"\t#convolOut : "<<(cs.num_convol_outputs(0))<<"\t#convol : "<<(cs.num_convol)<<std::endl;

			std::vector<FieldT> At, Bt, Ct, Ht;


			std::cout<<"test 4^-1: "<<FieldT(4).inverse().as_ulong()<<", -1 : "<<FieldT(-1).as_ulong()<<std::endl;
			
			At.resize(cs.num_variables()+1, FieldT::zero());
			Bt.resize(cs.num_variables()+1, FieldT::zero());
			Ct.resize(cs.num_variables()+1, FieldT::zero());
			Ht.reserve(domain->m+1);
			const FieldT Zt = domain->compute_vanishing_polynomial(t);

			libff::enter_block("Compute evaluations of A, B, C, H at t");
			const std::vector<FieldT> u = domain->evaluate_all_lagrange_polynomials(t);
			/**
			 * add and process the constraints
			 *     input_i * 0 = 0
			 * to ensure soundness of input consistency			 */
			/*
			for(size_t j=0;j<cs.num_variables();j++){
				
				for(size_t i=0;i<cs.num_constraints();i++){
					if(i==0) std::cout<<j<<"\t";
					std::cout<<cs.constraints[i].a.terms[j].coeff.as_ulong()<<"\t";
				}
				std::cout<<std::endl;
				
			}
			*/
			//std::cout<<"At ";
			for (size_t i = 0; i <= cs.num_inputs(); ++i)
			{
				At[i] = u[cs.num_constraints() + i];
				//std::cout<<i<<", "<<cs.num_constraints()+i<<"\t";
			}
			//std::cout<<std::endl;
			/* process all other constraints */

			size_t conv_index_a = 0;
			size_t conv_index_b = 0;
			size_t conv_index_c = 0;

			size_t conv_index_a2 = 0;
			size_t conv_index_b2 = 0;
			size_t conv_index_c2 = 0;

			bool conv_flag = true;

			if(cs.num_convol){

				libff::enter_block("Compute temps");
				vector<vector<vector<FieldT>>> temp11,temp22;
				temp11.reserve(cs.num_convol);
				temp22.reserve(cs.num_convol);
				for (size_t i = 0; i < cs.num_convol; ++i)
				{
					vector<vector<FieldT>> tv1(cs.num_convol_outputs(i), vector<FieldT>(cs.num_convol_outputs(i), FieldT::zero()));
					vector<vector<FieldT>> tv2(cs.num_convol_outputs2(i), vector<FieldT>(cs.num_convol_outputs2(i), FieldT::zero()));
					temp11.push_back(tv1);
					temp22.push_back(tv2);
					for(size_t k=0;k<cs.num_convol_outputs(i);k++){
						temp11[i][k][0] = FieldT::one();
						for(size_t kk=0;kk<cs.num_convol_outputs(i);kk++){
							temp11[i][k][kk] = temp11[i][k][kk-1]*FieldT(k+1);
						}
					}
					for(size_t j=0;j<cs.num_convol_outputs2(i);j++){
						temp22[i][j][0] = FieldT::one();
						for(size_t jj=0;jj<cs.num_convol_outputs(i);jj++){
							temp22[i][j][jj] = temp22[i][j][jj-1]*FieldT(j+1);
						}
					}
				}
				
				//libff::enter_block("Cal test");
				vector<FieldT> test(cs.num_convol_outputs(0)*cs.num_convol_outputs2(0), FieldT::zero());
				for (size_t i = 0; i < cs.num_constraints(); ++i){
					if(cs.constraints[i].a1.terms.size()>1){
					for(int x=0;x<cs.num_convol_outputs(0)-2;x++){
						for(int j=0;j<cs.num_convol_outputs2(0)-2;j++){
							size_t u_index = (cs.num_inputs()+1+cs.num_constraints()) + (x*(cs.num_convol_outputs2(0))) + j;
							for(int k=0;k<cs.num_convol_outputs(0)-2;k++){
								for(int l=0;l<cs.num_convol_outputs2(0)-2;l++){
									test[k*cs.num_convol_outputs2(0) +l] = temp11[0][x][k]*temp22[0][j][l];
								}
							}
							for(int k=0;k<cs.num_convol_input_height(0)-2;k++){
								for(int l=0;l<cs.num_convol_input_width(0)-2;l++){
									size_t a_index = k*cs.num_convol_input_width(0) + l;
									At[cs.constraints[i].a1.terms[a_index].index] += 
										u[u_index] * test[k*cs.num_convol_outputs2(0)+l];//temp11[0][i][k]*temp22[0][j][l];
								}
							}
							for(int k=0;k<cs.num_convol_kernel_height(0)-2;k++){
								for(int l=0;l<cs.num_convol_kernel_width(0)-2;l++){
									size_t b_index = k*cs.num_convol_kernel_width(0) + l;
									Bt[cs.constraints[i].b1.terms[b_index].index] += 
										u[u_index] * test[k*cs.num_convol_outputs2(0)+l];//temp11[0][i][k]*temp22[0][j][l];
								}
							}
							for(int k=0;k<cs.num_convol_outputs(0)-2;k++){
								for(int l=0;l<cs.num_convol_outputs2(0)-2;l++){
									size_t c_index = k*cs.num_convol_outputs2(0) + l;
									Ct[cs.constraints[i].c1.terms[c_index].index] += 
										u[u_index] * test[k*cs.num_convol_outputs2(0)+l];//temp11[0][i][k]*temp22[0][j][l];
								}
							}
						}
					}
					}
				}
				//libff::leave_block("Cal test");
				libff::leave_block("Compute temps");
			}
			
			for (size_t i = 0; i < cs.num_constraints(); ++i)
			{
				//std::cout<<"At\n";
				for (size_t j = 0; j < cs.constraints[i].a.terms.size(); ++j)
				{
					At[cs.constraints[i].a.terms[j].index] +=
						u[i]*cs.constraints[i].a.terms[j].coeff;
					//std::cout<<"( "<<i<<", "<<cs.constraints[i].a.terms[j].index<<")="<<cs.constraints[i].a.terms[j].coeff.as_ulong()<<"\n";
				}
				//std::cout<<std::endl;
				//std::cout<<"bt\n";
				for (size_t j = 0; j < cs.constraints[i].b.terms.size(); ++j)
				{
					Bt[cs.constraints[i].b.terms[j].index] +=
						u[i]*cs.constraints[i].b.terms[j].coeff;
					//std::cout<<"( "<<i<<", "<<cs.constraints[i].b.terms[j].index<<")="<<cs.constraints[i].b.terms[j].coeff.as_ulong()<<"\n";

				}
				//std::cout<<"Ct\n";
				for (size_t j = 0; j < cs.constraints[i].c.terms.size(); ++j)
				{
					Ct[cs.constraints[i].c.terms[j].index] +=
						u[i]*cs.constraints[i].c.terms[j].coeff;					
					//std::cout<<"( "<<i<<", "<<cs.constraints[i].c.terms[j].index<<")="<<cs.constraints[i].c.terms[j].coeff.as_ulong()<<"\n";

				}
				//if(cs.num_convol_dimensions(0) == 2){
				//std::cout<<"a1 size : "<<cs.constraints[i].a1.terms.size()<<std::endl;
			}

// 			libff::enter_block("Cal Conv");
// 			for (size_t i = 0; i < cs.num_constraints(); ++i)
// 			{
// 				if(cs.constraints[i].a1.terms.size()>1){
					
					

// 					for(size_t k=0;k<cs.num_convol_outputs(conv_index_a);k++){
// 							///TODO change (j+1) to safe value like prime
// 						//std::cout<<conv_index_a << ", "<<cs.num_convol_outputs(conv_index_a)<<std::endl;
// 						for(size_t l=0;l<cs.num_convol_outputs2(conv_index_a);l++){//l<1;l++){//cs.num_convol_outputs2(conv_index_a);l++){
// 							/*
// 							//FieldT temp = FieldT::one();
// 							vector<FieldT> temp1, temp2;
// 							temp1.reserve(cs.num_convol_outputs(conv_index_a));
// 							temp2.reserve(cs.num_convol_outputs2(conv_index_a));
// 							temp1[0] = FieldT::one();
// 							temp2[0] = FieldT::one();
// 							for(size_t kk=1;kk<cs.num_convol_outputs(conv_index_a);kk++){
// 								temp1[kk] = temp1[kk-1]*FieldT(k+1);
// 								//cout<<"t1 : "<<temp1[kk].as_ulong()<<endl;
// 							}
// 							for(size_t ll=1;ll<cs.num_convol_outputs2(conv_index_a);ll++){
// 								temp2[ll] = temp2[ll-1]*FieldT(l+1);
// 								//cout<<"t2 : "<<temp2[ll].as_ulong()<<endl;
// 							}
// 							*/
// 							size_t u_index = (cs.num_inputs()+1+cs.num_constraints()) + (k*(cs.num_convol_outputs2(conv_index_a))) + l;
// 							for(size_t j=0;j<(cs.constraints[i].a1.terms.size()-1)/cs.num_convol_input_width(conv_index_a);j++){
// 								//FieldT temp22 = FieldT::one();
// 								for(size_t m =0;m<(cs.constraints[i].a1.terms.size()-1)/cs.num_convol_input_height(conv_index_a);m++){
// 									size_t a_index = j*cs.num_convol_input_width(conv_index_a) + m+1;
// 									//std::cout<<"u : "<<u_index<<", a :"<<a_index<<"m conv_a :"<<conv_index_a<<std::endl;

// 									for(size_t depth=0;depth<conv_index_a;depth++){
// 											u_index += cs.num_convol_outputs(depth)*cs.num_convol_outputs2(depth);
// 											//a_index += cs.num_convol_input_height(depth)*cs.num_convol_input_width(depth);
											
// 									}
// 									//std::cout<<"u : "<<u_index<<", a :"<<a_index<<"m conv_a :"<<conv_index_a<<std::endl;
// 									if(cs.constraints[i].a1.terms[a_index].index){
// 										//cout<<"t1 : "<<temp1[j].as_ulong()<<", t11 : "<<temp.as_ulong()<<endl;
// 										//cout<<"t2 : "<<temp2[m].as_ulong()<<", t22 : "<<temp22.as_ulong()<<endl;
										
// 										//std::cout<<"( "<<i<<", "<<cs.constraints[i].a1.terms[j*cs.num_convol_input_width() + m+1].index<<")="<<cs.constraints[i].a1.terms[j*cs.num_convol_input_width() + m+1].coeff.as_ulong()<<"\n";
// 									//for(size_t k=0;k<cs.num_convol_outputs();k++){
// 										//temp = (FieldT(k+1)^(cs.constraints[i].a1.terms[j].coeff.as_ulong()-1));
// //									
// //										std::cout<<"At["<<(cs.constraints[i].a1.terms[a_index].index)<<
// //											"] = u["<<u_index <<"]"<<std::endl;
// 										At[cs.constraints[i].a1.terms[a_index].index] +=
// 											u[u_index] * temp11[conv_index_a][k][j]*temp22[conv_index_a][l][m]; //temp1[j] * temp2[m];//temp * temp2;//(FieldT(k+1)^cs.constraints[i].c1.terms[j].coeff.as_ulong());
									
// 										//	u[(cs.num_inputs()+1+cs.num_constraints())+(cs.num_convol_outputs())*(conv_index_a-1)+k] * (FieldT(k+1)^cs.constraints[i].a1.terms[j].coeff.as_ulong());
										
// 										//std::cout<<"#in : "<<cs.num_inputs()<<" #cons : "<<cs.num_constraints()<<" #convOut : "<<cs.num_convol_outputs()<<" convIndex :"<<conv_index_a<<" k :"<<k<<std::endl;
										
// //										std::cout<<"At["<<(cs.constraints[i].a1.terms[a_index].index)<<
// //											"] = u["<<u_index <<"]*("<<
// //											k+1<<")^"<<cs.constraints[i].a1.terms[a_index].coeff.as_ulong()-1<<"*("<<l+1<<")^"<<cs.constraints[i].a2.terms[a_index].coeff.as_ulong()-1<<
// //											"= "<<temp.as_ulong()<<"*"<<temp2.as_ulong()<<"\n";	
										
										
// 									//temp22 *= FieldT(l+1);
// 									}
// 								}
// 								//temp *= FieldT(k+1);
// 							}

// 							for(size_t j=0;j<(cs.constraints[i].b1.terms.size()-1)/cs.num_convol_kernel_width(conv_index_a);j++){
// 								//FieldT temp2 = FieldT::one();
// 								for(size_t m =0;m<(cs.constraints[i].b1.terms.size()-1)/cs.num_convol_kernel_height(conv_index_a);m++){
// 									if(cs.constraints[i].b1.terms[j*cs.num_convol_kernel_width(conv_index_a) + m+1].index){
// 										//std::cout<<"( "<<i<<", "<<cs.constraints[i].b1.terms[j*cs.num_convol_kernel_width() + m+1].index<<")="<<cs.constraints[i].b1.terms[j*cs.num_convol_kernel_width() + m+1].coeff.as_ulong()<<"\n";
// 									//for(size_t k=0;k<cs.num_convol_outputs();k++){
// 										//temp = (FieldT(k+1)^(cs.constraints[i].a1.terms[j].coeff.as_ulong()-1));
// 										//size_t u_index = (cs.num_inputs()+1+cs.num_constraints()) + k*(cs.num_convol_outputs2(conv_index_a)) + l;
// 										size_t b_index = j*cs.num_convol_kernel_width(conv_index_a) + m+1;
										
// 										for(size_t depth=0;depth<conv_index_a;depth++){
// 												u_index += cs.num_convol_outputs(depth)*cs.num_convol_outputs2(depth);
// 												//b_index += cs.num_convol_kernel_height(depth)*cs.num_convol_kernel_width(depth);
												
// 										}
// 										Bt[cs.constraints[i].b1.terms[b_index].index] +=
// 											u[u_index] * temp11[conv_index_a][k][j]*temp22[conv_index_a][l][m]; //temp1[j] * temp2[m];//temp * temp2;//(FieldT(k+1)^cs.constraints[i].c1.terms[j].coeff.as_ulong());
// 											//u[u_index] * temp1[j]*temp2[m];//temp * temp2;//(FieldT(k+1)^cs.constraints[i].c1.terms[j].coeff.as_ulong());
// //										std::cout<<"Bt["<<(cs.constraints[i].b1.terms[b_index].index)<<
// //											"] = u["<<u_index <<"]"<<std::endl;
										
										
// 										//	u[(cs.num_inputs()+1+cs.num_constraints())+(cs.num_convol_outputs())*(conv_index_a-1)+k] * (FieldT(k+1)^cs.constraints[i].a1.terms[j].coeff.as_ulong());
										
// 										//mastd::cout<<"#in : "<<cs.num_inputs()<<" #cons : "<<cs.num_constraints()<<" #convOut : "<<cs.num_convol_outputs()<<" convIndex :"<<conv_index_a<<" k :"<<k<<std::endl;
// 										/*
// 										std::cout<<"Bt["<<(cs.constraints[i].b1.terms[j*cs.num_convol_kernel_width() + m+1].index)<<
// 											"] = u["<<(cs.num_inputs()+1+cs.num_constraints()) + k*(cs.num_convol_kernel_width()) + l   <<
// 											"]*("<<k+1<<")^"<<cs.constraints[i].b1.terms[j*cs.num_convol_kernel_width() + m+1].coeff.as_ulong()-1<<"*("<<l+1<<")^"<<cs.constraints[i].b2.terms[j*cs.num_convol_kernel_width() + m+1].coeff.as_ulong()-1<<
// 											"= "<<temp.as_ulong()<<"*"<<temp2.as_ulong()<<"\n";	
// 										*/
// 									//temp2 *= FieldT(l+1);
// 									}
// 								}
// 								//temp *= FieldT(k+1);
// 							}

// 							////CCC/////
// 							for(size_t j=0;j<(cs.constraints[i].c1.terms.size()-1)/cs.num_convol_outputs2(conv_index_a);j++){
// 								//FieldT temp2 = FieldT::one();
// 								for(size_t m =0;m<(cs.constraints[i].c1.terms.size()-1)/cs.num_convol_outputs(conv_index_a);m++){
// 									if(cs.constraints[i].c1.terms[j*cs.num_convol_outputs2(conv_index_a) + m+1].index){
// 										//std::cout<<"( "<<i<<", "<<cs.constraints[i].c1.terms[j*cs.num_convol_outputs2() + m+1].index<<")="<<cs.constraints[i].c1.terms[j*cs.num_convol_outputs2() + m+1].coeff.as_ulong()<<"\n";
// 									//for(size_t k=0;k<cs.num_convol_outputs();k++){
// 										//temp = (FieldT(k+1)^(cs.constraints[i].a1.terms[j].coeff.as_ulong()-1));
// 										//cout<<"t1 : "<<temp1[j].as_ulong()<<endl;
// 										//cout<<"t2 : "<<temp2[m].as_ulong()<<endl;
// 										//size_t u_index = (cs.num_inputs()+1+cs.num_constraints()) + k*(cs.num_convol_outputs2(conv_index_a)) + l;
// 										size_t c_index = j*cs.num_convol_outputs2(conv_index_a) + m+1;
										
										
// 										for(size_t depth=0;depth<conv_index_a;depth++){
// 												u_index += cs.num_convol_outputs(depth)*cs.num_convol_outputs2(depth);
// 												//c_index += cs.num_convol_outputs(depth)*cs.num_convol_outputs2(depth);

// 										}
// 										Ct[cs.constraints[i].c1.terms[c_index].index] +=
// 											u[u_index] * temp11[conv_index_a][k][j]*temp22[conv_index_a][l][m]; //temp1[j] * temp2[m];//temp * temp2;//(FieldT(k+1)^cs.constraints[i].c1.terms[j].coeff.as_ulong());
// 											//u[u_index] * temp1[j] * temp2[m];//(FieldT(k+1)^cs.constraints[i].c1.terms[j].coeff.as_ulong());
									
// 										//	u[(cs.num_inputs()+1+cs.num_constraints())+(cs.num_convol_outputs())*(conv_index_a-1)+k] * (FieldT(k+1)^cs.constraints[i].a1.terms[j].coeff.as_ulong());
										
// 										//mastd::cout<<"#in : "<<cs.num_inputs()<<" #cons : "<<cs.num_constraints()<<" #convOut : "<<cs.num_convol_outputs()<<" convIndex :"<<conv_index_a<<" k :"<<k<<std::endl;
// 										/*
// 										std::cout<<"Ct["<<(cs.constraints[i].c1.terms[j*cs.num_convol_outputs2() + m+1].index)<<
// 											"] = u["<<(cs.num_inputs()+1+cs.num_constraints()) + k*(cs.num_convol_outputs2()) + l   <<
// 											"]*("<<k+1<<")^"<<cs.constraints[i].c1.terms[j*cs.num_convol_outputs2() + m+1].coeff.as_ulong()-1<<"*("<<l+1<<")^"<<cs.constraints[i].c2.terms[j*cs.num_convol_outputs2() + m+1].coeff.as_ulong()-1<<
// 											"= "<<temp.as_ulong()<<"*"<<temp2.as_ulong()<<"\n";
// 										*/
// 									//temp2 *= FieldT(l+1);
// 									}
// 								}
// 								//temp *= FieldT(k+1);
// 							}
// 						}
// 					}
						

					
					
// 					/*
// 					for(size_t k=0;k<cs.num_convol_outputs(conv_index_a);k++){
// 							///TODO change (j+1) to safe value like prime
// 						for(size_t l=0;l<cs.num_convol_outputs2(conv_index_a);l++){
// 							FieldT temp = FieldT::one();
// 							for(size_t j=0;j<(cs.constraints[i].b1.terms.size()-1)/cs.num_convol_kernel_width(conv_index_a);j++){
// 								FieldT temp2 = FieldT::one();
// 								for(size_t m =0;m<(cs.constraints[i].b1.terms.size()-1)/cs.num_convol_kernel_height(conv_index_a);m++){
// 									if(cs.constraints[i].b1.terms[j*cs.num_convol_kernel_width(conv_index_a) + m+1].index){
// 										//std::cout<<"( "<<i<<", "<<cs.constraints[i].b1.terms[j*cs.num_convol_kernel_width() + m+1].index<<")="<<cs.constraints[i].b1.terms[j*cs.num_convol_kernel_width() + m+1].coeff.as_ulong()<<"\n";
// 									//for(size_t k=0;k<cs.num_convol_outputs();k++){
// 										//temp = (FieldT(k+1)^(cs.constraints[i].a1.terms[j].coeff.as_ulong()-1));
// 										size_t u_index = (cs.num_inputs()+1+cs.num_constraints()) + k*(cs.num_convol_outputs2(conv_index_a)) + l;
// 										size_t b_index = j*cs.num_convol_kernel_width(conv_index_a) + m+1;
										
// 										for(size_t depth=0;depth<conv_index_a;depth++){
// 												u_index += cs.num_convol_outputs(depth)*cs.num_convol_outputs2(depth);
// 												//b_index += cs.num_convol_kernel_height(depth)*cs.num_convol_kernel_width(depth);
												
// 										}
// 										Bt[cs.constraints[i].b1.terms[b_index].index] +=
// 											u[u_index] * temp * temp2;//(FieldT(k+1)^cs.constraints[i].c1.terms[j].coeff.as_ulong());
// //										std::cout<<"Bt["<<(cs.constraints[i].b1.terms[b_index].index)<<
// //											"] = u["<<u_index <<"]"<<std::endl;
										
										
// 										//	u[(cs.num_inputs()+1+cs.num_constraints())+(cs.num_convol_outputs())*(conv_index_a-1)+k] * (FieldT(k+1)^cs.constraints[i].a1.terms[j].coeff.as_ulong());
										
// 										//mastd::cout<<"#in : "<<cs.num_inputs()<<" #cons : "<<cs.num_constraints()<<" #convOut : "<<cs.num_convol_outputs()<<" convIndex :"<<conv_index_a<<" k :"<<k<<std::endl;
										
// 										std::cout<<"Bt["<<(cs.constraints[i].b1.terms[j*cs.num_convol_kernel_width() + m+1].index)<<
// 											"] = u["<<(cs.num_inputs()+1+cs.num_constraints()) + k*(cs.num_convol_kernel_width()) + l   <<
// 											"]*("<<k+1<<")^"<<cs.constraints[i].b1.terms[j*cs.num_convol_kernel_width() + m+1].coeff.as_ulong()-1<<"*("<<l+1<<")^"<<cs.constraints[i].b2.terms[j*cs.num_convol_kernel_width() + m+1].coeff.as_ulong()-1<<
// 											"= "<<temp.as_ulong()<<"*"<<temp2.as_ulong()<<"\n";	
										
// 									temp2 *= FieldT(l+1);
// 									}
// 								}
// 								temp *= FieldT(k+1);
// 							}
// 						}
// 					}
// 					*/


// 					/*
// 					for(size_t k=0;k<cs.num_convol_outputs(conv_index_a);k++){
// 							///TODO change (j+1) to safe value like prime
// 						for(size_t l=0;l<cs.num_convol_outputs2(conv_index_a);l++){
// 							FieldT temp = FieldT::one();
// 							for(size_t j=0;j<(cs.constraints[i].c1.terms.size()-1)/cs.num_convol_outputs2(conv_index_a);j++){
// 								FieldT temp2 = FieldT::one();
// 								for(size_t m =0;m<(cs.constraints[i].c1.terms.size()-1)/cs.num_convol_outputs(conv_index_a);m++){
// 									if(cs.constraints[i].c1.terms[j*cs.num_convol_outputs2(conv_index_a) + m+1].index){
// 										//std::cout<<"( "<<i<<", "<<cs.constraints[i].c1.terms[j*cs.num_convol_outputs2() + m+1].index<<")="<<cs.constraints[i].c1.terms[j*cs.num_convol_outputs2() + m+1].coeff.as_ulong()<<"\n";
// 									//for(size_t k=0;k<cs.num_convol_outputs();k++){
// 										//temp = (FieldT(k+1)^(cs.constraints[i].a1.terms[j].coeff.as_ulong()-1));
// 										size_t u_index = (cs.num_inputs()+1+cs.num_constraints()) + k*(cs.num_convol_outputs2(conv_index_a)) + l;
// 										size_t c_index = j*cs.num_convol_outputs2(conv_index_a) + m+1;
										
										
// 										for(size_t depth=0;depth<conv_index_a;depth++){
// 												u_index += cs.num_convol_outputs(depth)*cs.num_convol_outputs2(depth);
// 												//c_index += cs.num_convol_outputs(depth)*cs.num_convol_outputs2(depth);

// 										}
// 										Ct[cs.constraints[i].c1.terms[c_index].index] +=
// 											u[u_index] * temp * temp2;//(FieldT(k+1)^cs.constraints[i].c1.terms[j].coeff.as_ulong());
									
// 										//	u[(cs.num_inputs()+1+cs.num_constraints())+(cs.num_convol_outputs())*(conv_index_a-1)+k] * (FieldT(k+1)^cs.constraints[i].a1.terms[j].coeff.as_ulong());
										
// 										//mastd::cout<<"#in : "<<cs.num_inputs()<<" #cons : "<<cs.num_constraints()<<" #convOut : "<<cs.num_convol_outputs()<<" convIndex :"<<conv_index_a<<" k :"<<k<<std::endl;
										
// 										std::cout<<"Ct["<<(cs.constraints[i].c1.terms[j*cs.num_convol_outputs2() + m+1].index)<<
// 											"] = u["<<(cs.num_inputs()+1+cs.num_constraints()) + k*(cs.num_convol_outputs2()) + l   <<
// 											"]*("<<k+1<<")^"<<cs.constraints[i].c1.terms[j*cs.num_convol_outputs2() + m+1].coeff.as_ulong()-1<<"*("<<l+1<<")^"<<cs.constraints[i].c2.terms[j*cs.num_convol_outputs2() + m+1].coeff.as_ulong()-1<<
// 											"= "<<temp.as_ulong()<<"*"<<temp2.as_ulong()<<"\n";
										
// 									//temp2 *= FieldT(l+1);
// 									}
// 								}
// 								//temp *= FieldT(k+1);
// 							}
// 						}
// 					}
// 					*/
// 					conv_index_a++;
// 				}
			
// 				//}
// 				/*
// 				else{
// 					bool flag = true;
// 					for(size_t k=0;k<cs.num_convol_outputs(0);k++){

// 						///TODO change (j+1) to safe value like prime
// 						FieldT temp = FieldT::one();
// 						for(size_t j=0;j<cs.constraints[i].a1.terms.size() != 0;j++){
// 							if(cs.constraints[i].a1.terms[j].index){
							
// 							if(flag){
// 								conv_index_a ++;
// 								flag = false;
// 							}
// 							//std::cout<<"( "<<i<<", "<<cs.constraints[i].a1.terms[j].index<<")="<<cs.constraints[i].a1.terms[j].coeff.as_ulong()<<"\n";

// 						//for(size_t k=0;k<cs.num_convol_outputs();k++){
// 							//temp = (FieldT(k+1)^(cs.constraints[i].a1.terms[j].coeff.as_ulong()-1));
// 							At[cs.constraints[i].a1.terms[j].index] +=
// 								u[(cs.num_inputs()+1+cs.num_constraints()) + (cs.num_convol_outputs(0)) *(conv_index_a-1) + k ] * temp;//(FieldT(k+1)^cs.constraints[i].c1.terms[j].coeff.as_ulong());
// 							//	u[(cs.num_inputs()+1+cs.num_constraints())+(cs.num_convol_outputs())*(conv_index_a-1)+k] * (FieldT(k+1)^cs.constraints[i].a1.terms[j].coeff.as_ulong());
							
// 							std::cout<<"#in : "<<cs.num_inputs()<<" #cons : "<<cs.num_constraints()<<" #convOut : "<<cs.num_convol_outputs()<<" convIndex :"<<conv_index_a<<" k :"<<k<<std::endl;
// 							std::cout<<"At["<<(cs.constraints[i].a1.terms[j].index)<<
// 								"] = u["<<(cs.num_inputs()+1+cs.num_constraints()) + (cs.num_convol_outputs()) *(conv_index_a-1) + k <<
// 								"]*("<<k+1<<")^"<<cs.constraints[i].a1.terms[j].coeff.as_ulong()<<
// 								"= "<<temp.as_ulong()<<"\n";
							
							
// 							temp *= FieldT(k+1);
// 							}

							
// 						}
// 					}
					
// 					flag = true;
// 					for(size_t k=0;k<cs.num_convol_outputs(0);k++){
// 						///TODO change (j+1) to safe value like prime
// 						FieldT temp = FieldT::one();
						
// 						for(size_t j=0;j<cs.constraints[i].b1.terms.size();j++){
// 							if(cs.constraints[i].b1.terms[j].index){
// 							if(flag){
// 								conv_index_b ++;
// 								flag = false;
// 							}
// 							//std::cout<<"( "<<i<<", "<<cs.constraints[i].b1.terms[j].index<<")="<<cs.constraints[i].b1.terms[j].coeff.as_ulong()<<"\n";

// 							//temp = (FieldT(k+1)^(cs.constraints[i].b1.terms[j].coeff.as_ulong()-1));
// 							Bt[cs.constraints[i].b1.terms[j].index] +=
// 								u[(cs.num_inputs()+1+cs.num_constraints()) + (cs.num_convol_outputs(0)) *(conv_index_b-1) + k ] * temp;//(FieldT(k+1)^cs.constraints[i].c1.terms[j].coeff.as_ulong());
							
// 							//	u[(cs.num_inputs()+1+cs.num_constraints())+(cs.num_convol_outputs())*(conv_index_b-1)+k] * (FieldT(k+1)^cs.constraints[i].c1.terms[j].coeff.as_ulong());
							
// 							std::cout<<"Bt["<<(cs.constraints[i].b1.terms[j].index)<<
// 								"] = u["<<(cs.num_inputs()+1+cs.num_constraints())+(cs.num_convol_outputs())*(conv_index_b-1)+k<<
// 									"]*("<<k+1<<")^"<<cs.constraints[i].b1.terms[j].coeff.as_ulong()<<
// 									"= "<<temp.as_ulong()<<"\n";
							

// 							temp *= FieldT(k+1);
// 							}
// 						}
// 					}
// 					flag = true;
// 					for(size_t k=0;k<cs.num_convol_outputs(0);k++){
// 						///TODO change (j+1) to safe value like prime
// 						FieldT temp = FieldT::one();

// 						for(size_t j=0;j<cs.constraints[i].c1.terms.size();j++){
// 							if(cs.constraints[i].c1.terms[j].index){

// 							if(flag){
// 								conv_index_c ++;
// 								flag = false;
// 							} 
// 							std::cout<<"( "<<i<<", "<<cs.constraints[i].c1.terms[j].index<<")="<<cs.constraints[i].c1.terms[j].coeff.as_ulong()<<"\n";
// 							//temp = (FieldT(k+1)^(cs.constraints[i].c1.terms[j].coeff.as_ulong()-1));
// 							Ct[cs.constraints[i].c1.terms[j].index] +=
// 								u[(cs.num_inputs()+1+cs.num_constraints()) + (cs.num_convol_outputs(0)) *(conv_index_c-1) + k ] * temp;//(FieldT(k+1)^cs.constraints[i].c1.terms[j].coeff.as_ulong());
							
// 							//	u[(cs.num_inputs()+1+cs.num_constraints())+(cs.num_convol_outputs())*(conv_index_c-1)+k] * (FieldT(k+1)^cs.constraints[i].c1.terms[j].coeff.as_ulong());

							
// 							std::cout<<"Ct["<<(cs.constraints[i].c1.terms[j].index)<<
// 								"] = u["<<(cs.num_inputs()+1+cs.num_constraints())+(cs.num_convol_outputs())*(conv_index_c-1)+k<<
// 								"]*("<<j+1<<")^"<<cs.constraints[i].c1.terms[j].coeff.as_ulong()<<
// 								"= "<<temp.as_ulong()<<"\n";
							
// 							temp *= FieldT(k+1);
// 							}
// 						}
// 					}
// 				}
// 				*/
// 			}
// 			libff::leave_block("Cal Conv");

			FieldT ti = FieldT::one();
			for (size_t i = 0; i < domain->m+1; ++i)
			{
				Ht.emplace_back(ti);
				ti *= t;
			}
			libff::leave_block("Compute evaluations of A, B, C, H at t");

			libff::leave_block("Call to r1cs_to_qap_instance_map_with_evaluation");

			return qap_instance_evaluation<FieldT>(domain,
					cs.num_variables(),
					domain->m,
					cs.num_inputs(),
					t,
					std::move(At),
					std::move(Bt),
					std::move(Ct),
					std::move(Ht),
					Zt);
		}

	/**
	 * Witness map for the R1CS-to-QAP reduction.
	 *
	 * The witness map takes zero knowledge into account when d1,d2,d3 are random.
	 *
	 * More precisely, compute the coefficients
	 *     h_0,h_1,...,h_n
	 * of the polynomial
	 *     H(z) := (A(z)*B(z)-C(z))/Z(z)
	 * where
	 *   A(z) := A_0(z) + \sum_{k=1}^{m} w_k A_k(z) + d1 * Z(z)
	 *   B(z) := B_0(z) + \sum_{k=1}^{m} w_k B_k(z) + d2 * Z(z)
	 *   C(z) := C_0(z) + \sum_{k=1}^{m} w_k C_k(z) + d3 * Z(z)
	 *   Z(z) := "vanishing polynomial of set S"
	 * and
	 *   m = number of variables of the QAP
	 *   n = degree of the QAP
	 *
	 * This is done as follows:
	 *  (1) compute evaluations of A,B,C on S = {sigma_1,...,sigma_n}
	 *  (2) compute coefficients of A,B,C
	 *  (3) compute evaluations of A,B,C on T = "coset of S"
	 *  (4) compute evaluation of H on T
	 *  (5) compute coefficients of H
	 *  (6) patch H to account for d1,d2,d3 (i.e., add coefficients of the polynomial (A d2 + B d1 - d3) + d1*d2*Z )
	 *
	 * The code below is not as simple as the above high-level description due to
	 * some reshuffling to save space.
	 */
	template<typename FieldT>
		qap_witness<FieldT> r1cs_to_qap_witness_map(const r1cs_constraint_system<FieldT> &cs,
				const r1cs_primary_input<FieldT> &primary_input,
				const r1cs_auxiliary_input<FieldT> &auxiliary_input,
				const FieldT &d1,
				const FieldT &d2,
				const FieldT &d3)
		{
			libff::enter_block("Call to r1cs_to_qap_witness_map");

			/* sanity check */
			assert(cs.is_satisfied(primary_input, auxiliary_input));

			//const std::shared_ptr<libfqfft::evaluation_domain<FieldT> > domain = libfqfft::get_evaluation_domain<FieldT>(cs.num_constraints() + cs.num_inputs() + 1);
			//const std::shared_ptr<libfqfft::evaluation_domain<FieldT> > domain = libfqfft::get_evaluation_domain<FieldT>(cs.num_constraints() + cs.num_inputs() + 1 + (cs.num_convol_outputs())*(cs.num_convol()+1));
			//const std::shared_ptr<libfqfft::evaluation_domain<FieldT> > domain = libfqfft::get_evaluation_domain<FieldT>(cs.num_constraints() + cs.num_inputs() + 1 + (cs.num_convol_outputs(0))*(cs.num_convol_outputs2(0)));

			size_t degree = cs.num_constraints() + cs.num_inputs() + 1;
			for(size_t i=0;i<cs.num_convol;i++){
				degree += (cs.num_convol_outputs(i))*(cs.num_convol_outputs2(i));
			}
			const std::shared_ptr<libfqfft::evaluation_domain<FieldT> > domain = libfqfft::get_evaluation_domain<FieldT>(degree);


			//std::cout<<"#constraint : "<< cs.num_constraints()<<"\t#input : "<< cs.num_inputs()<<"\t#convolOut : "<<(cs.num_convol_outputs(0))<<"\t#convol : "<<(cs.num_convol)<<std::endl;
			r1cs_variable_assignment<FieldT> full_variable_assignment = primary_input;
			full_variable_assignment.insert(full_variable_assignment.end(), auxiliary_input.begin(), auxiliary_input.end());
			/*
			std::cout<<"variables : ";
			for(size_t i=0;i<full_variable_assignment.size();i++){
				std::cout<<full_variable_assignment[i].as_ulong()<<"\t";
			}
			*/
			std::cout<<"\n";
			//std::cout<<"degree : "<<domain->m<<" sum = "<<cs.num_constraints() + cs.num_inputs() + 1 + (cs.num_convol_outputs(0))*(cs.num_convol+1)<<"\n";

			libff::enter_block("Compute evaluation of polynomials A, B on set S");
			std::vector<FieldT> aA(domain->m, FieldT::zero()), aB(domain->m, FieldT::zero());
			std::vector<FieldT> aC(domain->m, FieldT::zero());

			/* account for the additional constraints input_i * 0 = 0 */
			for (size_t i = 0; i <= cs.num_inputs(); ++i)
			{
				aA[i+cs.num_constraints()] = (i > 0 ? full_variable_assignment[i-1] : FieldT::one());
				//std::cout<<"aA["<<i+cs.num_constraints()<<"] = "<<aA[i+cs.num_constraints()].as_ulong()<<std::endl;

			}
			/* account for all other constraints */
			for (size_t i = 0; i < cs.num_constraints(); ++i)
			{
				aA[i] += cs.constraints[i].a.evaluate(full_variable_assignment);
				//std::cout<<"aA["<<i<<"] = "<<aA[i].as_ulong()<<std::endl;
				aB[i] += cs.constraints[i].b.evaluate(full_variable_assignment);
				//std::cout<<"aB["<<i<<"] = "<<aB[i].as_ulong()<<std::endl;

			}

			size_t conv_index_a = 0;
			size_t conv_index = 0;
			size_t conv_index2 = 0;

			if(cs.num_convol){
				libff::enter_block("Compute temps");
				vector<vector<vector<FieldT>>> temp11,temp22;
				temp11.reserve(cs.num_convol);
				temp22.reserve(cs.num_convol);
				for (size_t i = 0; i < cs.num_convol; ++i)
				{
					vector<vector<FieldT>> tv1(cs.num_convol_outputs(i), vector<FieldT>(cs.num_convol_outputs(i), FieldT::zero()));
					vector<vector<FieldT>> tv2(cs.num_convol_outputs2(i), vector<FieldT>(cs.num_convol_outputs2(i), FieldT::zero()));
					temp11.push_back(tv1);
					temp22.push_back(tv2);
					for(size_t k=0;k<cs.num_convol_outputs(i);k++){
						temp11[i][k][0] = FieldT::one();
						for(size_t kk=0;kk<cs.num_convol_outputs(i);kk++){
							temp11[i][k][kk] = temp11[i][k][kk-1]*FieldT(k+1);
						}
					}
					for(size_t j=0;j<cs.num_convol_outputs2(i);j++){
						temp22[i][j][0] = FieldT::one();
						for(size_t jj=0;jj<cs.num_convol_outputs(i);jj++){
							temp22[i][j][jj] = temp22[i][j][jj-1]*FieldT(j+1);
						}
					}
				}
				libff::leave_block("Compute temps");

				libff::enter_block("Cal test");
				vector<FieldT> test(cs.num_convol_outputs(0)*cs.num_convol_outputs2(0), FieldT::zero());
				for (size_t i = 0; i < cs.num_constraints(); ++i){
					if(cs.constraints[i].a1.terms.size()>1){
						
					FieldT acc = FieldT::zero();
					for(int x=0;x<cs.num_convol_outputs(0)-2;x++){
						for(int j=0;j<cs.num_convol_outputs2(0)-2;j++){
							size_t u_index = (cs.num_inputs()+1+cs.num_constraints()) + (x*(cs.num_convol_outputs2(0))) + j;
							for(int k=0;k<cs.num_convol_outputs(0)-2;k++){
								for(int l=0;l<cs.num_convol_outputs2(0)-2;l++){
									test[k*cs.num_convol_outputs2(0) +l] = temp11[0][x][k]*temp22[0][j][l];
								}
							}
							for(int k=0;k<cs.num_convol_input_height(0)-2;k++){
								for(int l=0;l<cs.num_convol_input_width(0)-2;l++){
									size_t a_index = k*cs.num_convol_input_width(0) + l;
									acc = full_variable_assignment[cs.constraints[i].a1.terms[a_index].index-1] * test[k*cs.num_convol_outputs2(0)+l];
									aA[u_index] += acc;
								}
							}
							for(int k=0;k<cs.num_convol_kernel_height(0)-2;k++){
								for(int l=0;l<cs.num_convol_kernel_width(0)-2;l++){
									size_t b_index = k*cs.num_convol_kernel_width(0) + l;
									acc = full_variable_assignment[cs.constraints[i].b1.terms[b_index].index-1] * test[k*cs.num_convol_outputs2(0)+l];
									aB[u_index] += acc;
								}
							}
							for(int k=0;k<cs.num_convol_outputs(0)-2;k++){
								for(int l=0;l<cs.num_convol_outputs2(0)-2;l++){
									size_t c_index = k*cs.num_convol_outputs2(0) + l;
									acc = full_variable_assignment[cs.constraints[i].c1.terms[c_index].index-1] * test[k*cs.num_convol_outputs2(0)+l];
									aC[u_index] += acc;
								}
							}
						}
					}
					}
				}
				libff::leave_block("Cal test");
			}

			// libff::enter_block("Cal Conv A,B,C");
			// for( size_t i=0;i<cs.num_constraints();i++){
			// 	if(cs.constraints[i].a1.terms.size()>1){

			// 		FieldT acc = FieldT::zero();
			// 		for(size_t j=0;j<cs.num_convol_outputs(conv_index_a);j++){
			// 			for(size_t k=0;k<cs.num_convol_outputs2(conv_index_a);k++){//1;k++){//cs.num_convol_outputs2(conv_index_a);k++){
			// 				//FieldT temp = FieldT::one();
			// 				/*
			// 				size_t idx = 0;

			// 				vector<FieldT> temp1, temp2;
			// 				temp1.reserve(cs.num_convol_outputs(conv_index_a));
			// 				temp2.reserve(cs.num_convol_outputs2(conv_index_a));
			// 				temp1[0] = FieldT::one();
			// 				temp2[0] = FieldT::one();
			// 				for(size_t kk=1;kk<cs.num_convol_outputs(conv_index_a);kk++){
			// 					temp1[kk] = temp1[kk-1]*FieldT(j+1);
			// 					//cout<<"t1 : "<<temp1[kk].as_ulong()<<endl;
			// 				}
			// 				for(size_t ll=1;ll<cs.num_convol_outputs2(conv_index_a);ll++){
			// 					temp2[ll] = temp2[ll-1]*FieldT(k+1);
			// 					//cout<<"t2 : "<<temp2[ll].as_ulong()<<endl;
			// 				}
			// 				*/
							
			// 				//std::cout<<"A1 size = "<<cs.constraints[i].a1.terms.size()<<std::endl;
			// 				for(size_t l=0;l<(cs.constraints[i].a1.terms.size()-1)/cs.num_convol_input_width(conv_index_a);l++){
			// 					//FieldT temp2 = FieldT::one();
			// 					for(size_t m=0;m<(cs.constraints[i].a1.terms.size()-1)/cs.num_convol_input_height(conv_index_a);m++){
			// 						//std::cout<<l<<", "<<m<<" : "<<l*cs.num_convol_input_width()+m<<std::endl;
			// 						if(cs.constraints[i].a1.terms[l*cs.num_convol_input_width(conv_index_a)+m+1].index){
			// 							size_t u_index = (cs.num_inputs()+1+cs.num_constraints()) + j*(cs.num_convol_outputs2(conv_index_a)) + k;
			// 							size_t a_index = l*cs.num_convol_input_width(conv_index_a) + m+1;
										
										
			// 							for(size_t depth=0;depth<conv_index_a;depth++){
			// 									u_index += cs.num_convol_outputs(depth)*cs.num_convol_outputs2(depth);
			// 									//a_index += cs.num_convol_input_height(depth)*cs.num_convol_input_width(depth);

			// 							}
										
			// 							acc = full_variable_assignment[cs.constraints[i].a1.terms[a_index].index-1] *temp11[conv_index_a][j][l]*temp22[conv_index_a][k][m];// temp1[l] * temp2[m];//(FieldT(j)^lt.coeff.as_ulong());

			// 							/*
			// 							std::cout<<"acc : "<<acc.as_ulong()<<" var["<<cs.constraints[i].a1.terms[l*cs.num_convol_input_width()+m+1].index-1<<"]*("<<
			// 								j+1<<"^"<<cs.constraints[i].a1.terms[l*cs.num_convol_input_width()+m+1].coeff.as_ulong()-1<<")*("
			// 								<<k+1<<"^"<<cs.constraints[i].a2.terms[l*cs.num_convol_input_width()+m+1].coeff.as_ulong()-1<<")=("<<
			// 								temp.as_ulong()<<"*"<<temp2.as_ulong()
			// 								<<")\n";
										
			// 							*/



			// 							aA[u_index] += acc;
			// 							//std::cout<<"aA["<<(j)*cs.num_convol_outputs2() + k+1+ cs.num_constraints() + cs.num_inputs()<<"] = acc\n";

			// 							/*
			// 							idx++;
			// 							if(idx == cs.num_convol_input_width()){
			// 								temp2 *= FieldT(j+1);
			// 								idx = 0;
			// 							}
			// 							*/
			// 							//temp2 *= FieldT(k+1);

			// 						}

			// 					}
			// 					//temp *= FieldT(j+1);
			// 				}
			// 				//////BBBBB

			// 				for(size_t l=0;l<(cs.constraints[i].b1.terms.size()-1)/cs.num_convol_kernel_width(conv_index_a);l++){
			// 					//FieldT temp2 = FieldT::one();
			// 					for(size_t m=0;m<(cs.constraints[i].b1.terms.size()-1)/cs.num_convol_kernel_height(conv_index_a);m++){
			// 						//std::cout<<l<<", "<<m<<" : "<<l*cs.num_convol_input_width()+m<<std::endl;
			// 						if(cs.constraints[i].b1.terms[l*cs.num_convol_kernel_width(conv_index_a)+m+1].index){

			// 							size_t u_index = (cs.num_inputs()+1+cs.num_constraints()) + j*(cs.num_convol_outputs2(conv_index_a)) + k;
			// 							size_t b_index = l*cs.num_convol_kernel_width(conv_index_a) + m+1;
										
										
			// 							for(size_t depth=0;depth<conv_index_a;depth++){
			// 									u_index += cs.num_convol_outputs(depth)*cs.num_convol_outputs2(depth);
			// 									//b_index += cs.num_convol_kernel_height(depth)*cs.num_convol_kernel_height(depth);

			// 							}
			// 							//acc = full_variable_assignment[cs.constraints[i].b1.terms[b_index].index-1] * temp1[l] * temp2[m];//(FieldT(j)^lt.coeff.as_ulong());
			// 							acc = full_variable_assignment[cs.constraints[i].b1.terms[b_index].index-1] *temp11[conv_index_a][j][l]*temp22[conv_index_a][k][m];// temp1[l] * temp2[m];//(FieldT(j)^lt.coeff.as_ulong());

			// 							/*
			// 							std::cout<<"acc : "<<acc.as_ulong()<<" var["<<cs.constraints[i].b1.terms[l*cs.num_convol_kernel_width()+m+1].index-1<<"]*("<<
			// 								j+1<<"^"<<cs.constraints[i].b1.terms[l*cs.num_convol_kernel_width()+m+1].coeff.as_ulong()-1<<")*("
			// 								<<k+1<<"^"<<cs.constraints[i].b2.terms[l*cs.num_convol_kernel_width()+m+1].coeff.as_ulong()-1<<")=("<<
			// 								temp.as_ulong()<<"*"<<temp2.as_ulong()
			// 								<<")\n";
			// 							*/
			// 							aB[u_index] += acc;
			// 							//std::cout<<"aB["<<(j)*cs.num_convol_outputs2() + k+1+ cs.num_constraints() + cs.num_inputs()<<"] = acc\n";
			// 							/*
			// 							idx++;
			// 							if(idx == cs.num_convol_kernel_width()){
			// 								temp2 *= FieldT(j+1);
			// 								idx = 0;
			// 							}
			// 							*/
			// 							//temp2 *= FieldT(k+1);

			// 						}
									
			// 					}
			// 					//temp *= FieldT(j+1);
			// 				}
			// 				///////CCCCC
			// 				for(size_t l=0;l<(cs.constraints[i].c1.terms.size()-1)/cs.num_convol_outputs2(conv_index_a);l++){
			// 					//FieldT temp2 = FieldT::one();
			// 					for(size_t m=0;m<(cs.constraints[i].c1.terms.size()-1)/cs.num_convol_outputs(conv_index_a);m++){
			// 						//std::cout<<l<<", "<<m<<" : "<<l*cs.num_convol_outputs2()+m<<std::endl;
			// 						if(cs.constraints[i].c1.terms[l*cs.num_convol_outputs2(conv_index_a)+m+1].index){
			// 							size_t u_index = (cs.num_inputs()+1+cs.num_constraints()) + j*(cs.num_convol_outputs2(conv_index_a)) + k;
			// 							size_t c_index = l*cs.num_convol_outputs2(conv_index_a) + m+1;
										
										
			// 							for(size_t depth=0;depth<conv_index_a;depth++){
			// 									u_index += cs.num_convol_outputs(depth)*cs.num_convol_outputs2(depth);
			// 									//c_index += cs.num_convol_outputs(depth)*cs.num_convol_outputs2(depth);

			// 							}
										
			// 							//acc = full_variable_assignment[cs.constraints[i].c1.terms[c_index].index-1] * temp1[l] * temp2[m];//(FieldT(j)^lt.coeff.as_ulong());
			// 							acc = full_variable_assignment[cs.constraints[i].c1.terms[c_index].index-1] *temp11[conv_index_a][j][l]*temp22[conv_index_a][k][m];// temp1[l] * temp2[m];//(FieldT(j)^lt.coeff.as_ulong());
			// 							/*
			// 							std::cout<<"acc : "<<acc.as_ulong()<<" var["<<cs.constraints[i].c1.terms[l*cs.num_convol_outputs2()+m+1].index-1<<"]*("<<
			// 								j+1<<"^"<<cs.constraints[i].c1.terms[l*cs.num_convol_outputs2()+m+1].coeff.as_ulong()-1<<")*("
			// 								<<k+1<<"^"<<cs.constraints[i].c2.terms[l*cs.num_convol_outputs2()+m+1].coeff.as_ulong()-1<<")=("<<
			// 								temp.as_ulong()<<"*"<<temp2.as_ulong()
			// 								<<")\n";
			// 							*/



			// 							aC[u_index] += acc;
			// 							//std::cout<<"aC["<<(j)*cs.num_convol_outputs2() + k+1+ cs.num_constraints() + cs.num_inputs()<<"] = acc\n";

			// 							/*
			// 							std::cout<<"idx : "<<idx<<std::endl;
			// 							idx++;
			// 							if(idx == cs.num_convol_outputs2()){
			// 								idx = 0;
			// 							}
			// 							*/
			// 							//temp2 *= FieldT(k+1);

			// 						}
			// 					}
			// 					//temp *= FieldT(j+1);
			// 				}

							
						
			// 			}
			// 		}
			// 		/*
			// 		for(size_t j=0;j<cs.num_convol_outputs(conv_index_a);j++){
			// 			for(size_t k=0;k<cs.num_convol_outputs2(conv_index_a);k++){
			// 				FieldT temp = FieldT::one();
			// 				//size_t idx = 0;
							
			// 				//std::cout<<"A1 size = "<<cs.constraints[i].b1.terms.size()<<std::endl;
			// 				for(size_t l=0;l<(cs.constraints[i].b1.terms.size()-1)/cs.num_convol_kernel_width(conv_index_a);l++){
			// 					FieldT temp2 = FieldT::one();
			// 					for(size_t m=0;m<(cs.constraints[i].b1.terms.size()-1)/cs.num_convol_kernel_height(conv_index_a);m++){
			// 						//std::cout<<l<<", "<<m<<" : "<<l*cs.num_convol_input_width()+m<<std::endl;
			// 						if(cs.constraints[i].b1.terms[l*cs.num_convol_kernel_width(conv_index_a)+m+1].index){

			// 							size_t u_index = (cs.num_inputs()+1+cs.num_constraints()) + j*(cs.num_convol_outputs2(conv_index_a)) + k;
			// 							size_t b_index = l*cs.num_convol_kernel_width(conv_index_a) + m+1;
										
										
			// 							for(size_t depth=0;depth<conv_index_a;depth++){
			// 									u_index += cs.num_convol_outputs(depth)*cs.num_convol_outputs2(depth);
			// 									//b_index += cs.num_convol_kernel_height(depth)*cs.num_convol_kernel_height(depth);

			// 							}
			// 							acc = full_variable_assignment[cs.constraints[i].b1.terms[b_index].index-1] * temp * temp2;//(FieldT(j)^lt.coeff.as_ulong());

										
			// 							std::cout<<"acc : "<<acc.as_ulong()<<" var["<<cs.constraints[i].b1.terms[l*cs.num_convol_kernel_width()+m+1].index-1<<"]*("<<
			// 								j+1<<"^"<<cs.constraints[i].b1.terms[l*cs.num_convol_kernel_width()+m+1].coeff.as_ulong()-1<<")*("
			// 								<<k+1<<"^"<<cs.constraints[i].b2.terms[l*cs.num_convol_kernel_width()+m+1].coeff.as_ulong()-1<<")=("<<
			// 								temp.as_ulong()<<"*"<<temp2.as_ulong()
			// 								<<")\n";
										
			// 							aB[u_index] += acc;
			// 							//std::cout<<"aB["<<(j)*cs.num_convol_outputs2() + k+1+ cs.num_constraints() + cs.num_inputs()<<"] = acc\n";
										
			// 							idx++;
			// 							if(idx == cs.num_convol_kernel_width()){
			// 								temp2 *= FieldT(j+1);
			// 								idx = 0;
			// 							}
										
			// 							temp2 *= FieldT(k+1);

			// 						}
									
			// 					}
			// 					temp *= FieldT(j+1);
			// 				}
							
						
			// 			}
			// 		}
			// 		*/

			//  		conv_index_a++;
			// 	}

	
			// }
			// /*
			
			// else{
			// 	for( size_t i=0;i<cs.num_constraints();i++){
			// 		FieldT acc = FieldT::zero();
			// 		bool flag = false;
			// 		for(size_t j=1;j<=cs.num_convol_outputs(0);j++){
						
			// 			FieldT temp = FieldT::one();
			// 			for(auto &lt : cs.constraints[i].a1){
			// 				if(lt.index){
			// 				if(!flag){ 
			// 					conv_index++;
			// 					flag = true;
			// 				}
			// 				//temp = (FieldT(j)^(lt.coeff.as_ulong()-1));
			// 				acc = full_variable_assignment[lt.index-1] * temp;//(FieldT(j)^lt.coeff.as_ulong());
			// 				//std::cout<<j<<"^"<<lt.coeff.as_ulong()<<" = "<<temp.as_ulong()<<std::endl;

			// 				temp *= FieldT(j);
			// 				//acc = full_variable_assignment[lt.index-1] * (FieldT(j)^lt.coeff.as_ulong());

			// 				//std::cout<<"acc : "<<acc.as_ulong()<<" var["<<lt.index-1<<"]*("<<j<<"^"<<lt.coeff.as_ulong()<<")\n";
			// 				//std::cout<<"j : "<<j<<" convIdx :"<<conv_index<<" #convOut : "<<cs.num_convol_outputs()<<" #cons : "<<cs.num_constraints()<<+" #in :"<<cs.num_inputs()<<std::endl;
			// 				aA[(j)+ cs.num_constraints() + cs.num_inputs()] += acc;
			// 				//std::cout<<"aA["<<(j)+(conv_index-1)*cs.num_convol_outputs() + cs.num_constraints() + cs.num_inputs()<<"] = acc\n";
			// 				}
			// 			}
			// 		}
			// 		/*
			// 		for(auto &lt : cs.constraints[i].a1){
			// 			if(!flag){ 
			// 				conv_index++;
			// 				flag = true;
			// 			}
			// 			FieldT temp = FieldT::one();
			// 			for(size_t j=1;j<=cs.num_convol_outputs();j++){
			// 				//if(lt.idex ==0) acc += (FieldT::one()*cs.conv_num_output()) * lt.coeff; //there is no first one in conv constraints
			// 				acc = full_variable_assignment[lt.index-1] * temp;//(FieldT(j)^lt.coeff.as_ulong());
			// 				temp *= FieldT(j);
			// 				//Fixing temp value
			// 				std::cout<<j<<"^"<<lt.coeff.as_ulong()<<" = "<<temp.as_ulong()<<std::endl;
			// 				//acc = full_variable_assignment[lt.index-1] * (FieldT(j)^lt.coeff.as_ulong());

			// 				std::cout<<"acc : "<<acc.as_ulong()<<" var["<<lt.index-1<<"]*("<<j<<"^"<<lt.coeff.as_ulong()<<")\n";
			// 				aA[(j)+(conv_index-1)*cs.num_convol_outputs() + cs.num_constraints() + cs.num_inputs()] += acc;
			// 				std::cout<<"aA["<<(j)+(conv_index-1)*cs.num_convol_outputs() + cs.num_constraints() + cs.num_inputs()<<"] = acc\n";
			// 			}
			// 			//if(acc != FieldT::zero()){
			// 			//}
						
					
					
			// 		for(size_t j=1;j<=cs.num_convol_outputs();j++){
			// 			std::cout<<"aA["<<(j)+cs.num_constraints()+cs.num_inputs()<<"] ="<<
			// 				aA[(j) + cs.num_constraints() + cs.num_inputs()].as_ulong() <<"\n";
			// 		}
					
				
			// 		acc = FieldT::zero();
			// 		flag = false;
			// 		for(size_t j=1;j<=cs.num_convol_outputs(0);j++){
						
			// 			FieldT temp = FieldT::one();
			// 			for(auto &lt : cs.constraints[i].b1){
			// 				if(lt.index){
			// 				if(!flag){ 
			// 					conv_index2++;
			// 					flag = true;
			// 				}
			// 				//temp = (FieldT(j)^(lt.coeff.as_ulong()-1));
			// 				acc = full_variable_assignment[lt.index-1] * temp;//(FieldT(j)^lt.coeff.as_ulong());
			// 				//std::cout<<j<<"^"<<lt.coeff.as_ulong()<<" = "<<temp.as_ulong()<<std::endl;

			// 				temp *= FieldT(j);
			// 				//acc = full_variable_assignment[lt.index-1] * (FieldT(j)^lt.coeff.as_ulong());

			// 				//std::cout<<"acc : "<<acc.as_ulong()<<" var["<<lt.index-1<<"]*("<<j<<"^"<<lt.coeff.as_ulong()<<")\n";
			// 				aB[(j)+(conv_index2-1)*cs.num_convol_outputs(0) + cs.num_constraints() + cs.num_inputs()] += acc;
			// 				//std::cout<<"j : "<<j<<" convind2-1 : "<<conv_index2-1<<" convout : "<<cs.num_convol_outputs()<<" cons+in : "<<cs.num_constraints() + cs.num_inputs()<<std::endl;
			// 				//std::cout<<"aB["<<(j)+(conv_index2-1)*cs.num_convol_outputs() + cs.num_constraints() + cs.num_inputs()<<"] = acc\n";
			// 				}
			// 			}
			// 		}
			// 		/*
			// 		for(auto &lt : cs.constraints[i].b1){
			// 			if(!flag){ 
			// 				conv_index2++;
			// 				flag = true;
			// 			}
			// 			FieldT temp = FieldT::one();
			// 			for(size_t j=1;j<=cs.num_convol_outputs();j++){
			// 				//acc = full_variable_assignment[lt.index-1] * temp;//(FieldT(j)^lt.coeff.as_ulong());
			// 				//temp *= FieldT(j);
			// 				acc = full_variable_assignment[lt.index-1] * (FieldT(j)^lt.coeff.as_ulong());

			// 				std::cout<<"acc : "<<acc.as_ulong()<<" var["<<lt.index-1<<"]*("<<j<<"^"<<lt.coeff.as_ulong()<<")\n";
			// 				aB[(j)+(conv_index2-1)*cs.num_convol_outputs() + cs.num_constraints() + cs.num_inputs()] += acc;
			// 				std::cout<<"aB["<<(j)+(conv_index2-1)*cs.num_convol_outputs() + cs.num_constraints() + cs.num_inputs()<<"] = acc\n";
			// 			}
			// 			//aB[i*cs.num_convol() + j + cs.num_constraints() + cs.num_inputs()] += acc;
			// 		}
					
			// 		for(size_t j=1;j<=cs.num_convol_outputs();j++){
			// 			std::cout<<"aB["<< +(j)+cs.num_constraints()+cs.num_inputs()<<"] ="<<
			// 				aB[(j) + cs.num_constraints() + cs.num_inputs()].as_ulong() <<"\n";
			// 		}
					
			// 	}
			// }
			// */
			// libff::leave_block("Cal Conv A,B,C");
			
			libff::leave_block("Compute evaluation of polynomials A, B on set S");

			libff::enter_block("Compute coefficients of polynomial A");
			domain->iFFT(aA);
			libff::leave_block("Compute coefficients of polynomial A");

			libff::enter_block("Compute coefficients of polynomial B");
			domain->iFFT(aB);
			libff::leave_block("Compute coefficients of polynomial B");

			libff::enter_block("Compute ZK-patch");
			std::vector<FieldT> coefficients_for_H(domain->m+1, FieldT::zero());
#ifdef MULTICORE
#pragma omp parallel for
#endif
			/* add coefficients of the polynomial (d2*A + d1*B - d3) + d1*d2*Z */
			for (size_t i = 0; i < domain->m; ++i)
			{
				coefficients_for_H[i] = d2*aA[i] + d1*aB[i];
			}
			coefficients_for_H[0] -= d3;
			domain->add_poly_Z(d1*d2, coefficients_for_H);
			libff::leave_block("Compute ZK-patch");

			libff::enter_block("Compute evaluation of polynomial A on set T");
			domain->cosetFFT(aA, FieldT::multiplicative_generator);
			libff::leave_block("Compute evaluation of polynomial A on set T");

			libff::enter_block("Compute evaluation of polynomial B on set T");
			domain->cosetFFT(aB, FieldT::multiplicative_generator);
			libff::leave_block("Compute evaluation of polynomial B on set T");

			libff::enter_block("Compute evaluation of polynomial H on set T");
			std::vector<FieldT> &H_tmp = aA; // can overwrite aA because it is not used later
#ifdef MULTICORE
#pragma omp parallel for
#endif
			for (size_t i = 0; i < domain->m; ++i)
			{
				H_tmp[i] = aA[i]*aB[i];
			}
			std::vector<FieldT>().swap(aB); // destroy aB

			libff::enter_block("Compute evaluation of polynomial C on set S");
			//std::vector<FieldT> aC(domain->m, FieldT::zero());
			for (size_t i = 0; i < cs.num_constraints(); ++i)
			{
				aC[i] += cs.constraints[i].c.evaluate(full_variable_assignment);
				//std::cout<<"aC["<<i<<"] = "<<aC[i].as_ulong()<<std::endl;

			}
			/*
			conv_index_a = 0;
			conv_index = 0;
			libff::enter_block("Cal Conv C");
			for( size_t i=0;i<cs.num_constraints();i++){
				FieldT acc = FieldT::zero();

				if(cs.constraints[i].a1.terms.size()>1){
					for(size_t j=0;j<cs.num_convol_outputs(conv_index_a);j++){
						for(size_t k=0;k<cs.num_convol_outputs2(conv_index_a);k++){
							FieldT temp = FieldT::one();
							size_t idx = 0;
							
							//std::cout<<"A1 size = "<<cs.constraints[i].c1.terms.size()<<std::endl;
							for(size_t l=0;l<(cs.constraints[i].c1.terms.size()-1)/cs.num_convol_outputs2(conv_index_a);l++){
								FieldT temp2 = FieldT::one();
								for(size_t m=0;m<(cs.constraints[i].c1.terms.size()-1)/cs.num_convol_outputs(conv_index_a);m++){
									//std::cout<<l<<", "<<m<<" : "<<l*cs.num_convol_outputs2()+m<<std::endl;
									if(cs.constraints[i].c1.terms[l*cs.num_convol_outputs2(conv_index_a)+m+1].index){
										size_t u_index = (cs.num_inputs()+1+cs.num_constraints()) + j*(cs.num_convol_outputs2(conv_index_a)) + k;
										size_t c_index = l*cs.num_convol_outputs2(conv_index_a) + m+1;
										
										
										for(size_t depth=0;depth<conv_index_a;depth++){
												u_index += cs.num_convol_outputs(depth)*cs.num_convol_outputs2(depth);
												//c_index += cs.num_convol_outputs(depth)*cs.num_convol_outputs2(depth);

										}
										
										acc = full_variable_assignment[cs.constraints[i].c1.terms[c_index].index-1] * temp * temp2;//(FieldT(j)^lt.coeff.as_ulong());
										
										std::cout<<"acc : "<<acc.as_ulong()<<" var["<<cs.constraints[i].c1.terms[l*cs.num_convol_outputs2()+m+1].index-1<<"]*("<<
											j+1<<"^"<<cs.constraints[i].c1.terms[l*cs.num_convol_outputs2()+m+1].coeff.as_ulong()-1<<")*("
											<<k+1<<"^"<<cs.constraints[i].c2.terms[l*cs.num_convol_outputs2()+m+1].coeff.as_ulong()-1<<")=("<<
											temp.as_ulong()<<"*"<<temp2.as_ulong()
											<<")\n";
										



										aC[u_index] += acc;
										//std::cout<<"aC["<<(j)*cs.num_convol_outputs2() + k+1+ cs.num_constraints() + cs.num_inputs()<<"] = acc\n";

										
										std::cout<<"idx : "<<idx<<std::endl;
										idx++;
										if(idx == cs.num_convol_outputs2()){
											idx = 0;
										}
										
										temp2 *= FieldT(k+1);

									}
								}
								temp *= FieldT(j+1);
							}

							
						
						}
					}
					conv_index_a++;
				}
			}
			*/
				/*
				else{
					bool flag = false;
					for(size_t j=1;j<=cs.num_convol_outputs(0);j++){
						
						FieldT temp = FieldT::one();
						for(auto &lt : cs.constraints[i].c1){
							if(lt.index){
							if(!flag){ 
								conv_index++;
								flag = true;
							}
							//temp = (FieldT(j)^(lt.coeff.as_ulong()-1));
							acc = full_variable_assignment[lt.index-1] * temp;//(FieldT(j)^lt.coeff.as_ulong());
							///TODO lt.index break when output is not used to sequentially   
							//acc = full_variable_assignment[lt.index-1] * (FieldT(j)^lt.coeff.as_ulong());
							//std::cout<<j<<"^"<<lt.coeff.as_ulong()<<" = "<<temp.as_ulong()<<std::endl;

							temp *= FieldT(j);
							aC[(j)+(conv_index-1)*cs.num_convol_outputs(0) + cs.num_constraints() + cs.num_inputs()] += acc;
							//std::cout<<"acc : "<<acc.as_ulong()<<" var["<<lt.index-1<<"]*("<<j<<"^"<<lt.coeff.as_ulong()<<")\n";
							//std::cout<<"aC["<<(j)+(conv_index-1)*cs.num_convol_outputs() + cs.num_constraints() + cs.num_inputs()<<"] = acc\n";
							}
						}
					}
				/*
				for(auto &lt : cs.constraints[i].c1){
					if(!flag){
						conv_index++;
						flag = true;
					}
					FieldT temp = FieldT::one();
					for(size_t j=1;j<=cs.num_convol_outputs();j++){
						//acc = full_variable_assignment[lt.index-1] * temp;//(FieldT(j)^lt.coeff.as_ulong());
						//temp *= FieldT(j);
						acc = full_variable_assignment[lt.index-1] * (FieldT(j)^lt.coeff.as_ulong());

						aC[(j)+(conv_index-1)*cs.num_convol_outputs() + cs.num_constraints() + cs.num_inputs()] += acc;
						std::cout<<"acc : "<<acc.as_ulong()<<" var["<<lt.index-1<<"]*("<<j<<"^"<<lt.coeff.as_ulong()<<")\n";
						std::cout<<"aC["<<(j)+(conv_index-1)*cs.num_convol_outputs() + cs.num_constraints() + cs.num_inputs()<<"] = acc\n";
					}
				}
				/*
				//for debug
				for(size_t j=1;j<=cs.num_convol_outputs();j++){
					std::cout<<"aC["<<(j)+cs.num_constraints()+cs.num_inputs()<<"] ="<<
						aC[(j) + cs.num_constraints() + cs.num_inputs()].as_ulong() <<"\n";
				}
				
				}

			}
			*/
			//libff::leave_block("Cal Conv C");
			libff::leave_block("Compute evaluation of polynomial C on set S");

			libff::enter_block("Compute coefficients of polynomial C");
			domain->iFFT(aC);
			libff::leave_block("Compute coefficients of polynomial C");

			libff::enter_block("Compute evaluation of polynomial C on set T");
			domain->cosetFFT(aC, FieldT::multiplicative_generator);
			libff::leave_block("Compute evaluation of polynomial C on set T");

#ifdef MULTICORE
#pragma omp parallel for
#endif
			for (size_t i = 0; i < domain->m; ++i)
			{
				H_tmp[i] = (H_tmp[i]-aC[i]);
			}

			libff::enter_block("Divide by Z on set T");
			domain->divide_by_Z_on_coset(H_tmp);
			libff::leave_block("Divide by Z on set T");

			libff::leave_block("Compute evaluation of polynomial H on set T");

			libff::enter_block("Compute coefficients of polynomial H");
			domain->icosetFFT(H_tmp, FieldT::multiplicative_generator);
			libff::leave_block("Compute coefficients of polynomial H");

			libff::enter_block("Compute sum of H and ZK-patch");
#ifdef MULTICORE
#pragma omp parallel for
#endif
			for (size_t i = 0; i < domain->m; ++i)
			{
				coefficients_for_H[i] += H_tmp[i];
			}
			libff::leave_block("Compute sum of H and ZK-patch");

			libff::leave_block("Call to r1cs_to_qap_witness_map");

			return qap_witness<FieldT>(cs.num_variables(),
					domain->m,
					cs.num_inputs(),
					d1,
					d2,
					d3,
					full_variable_assignment,
					std::move(coefficients_for_H));
		}



	/////NEW SYSTEM *******/////////

	/**
	 * Instance map for the R1CS-to-QAP reduction.
	 *
	 * Namely, given a R1CS constraint system cs, construct a QAP instance for which:
	 *   A := (A_0(z),A_1(z),...,A_m(z))
	 *   B := (B_0(z),B_1(z),...,B_m(z))
	 *   C := (C_0(z),C_1(z),...,C_m(z))
	 * where
	 *   m = number of variables of the QAP
	 * and
	 *   each A_i,B_i,C_i is expressed in the Lagrange basis.
	 */
	/*
	template<typename FieldT>
		 qap_instance<FieldT> r1cs_to_qap_instance_map(const r1cs_constraint_convol_system<FieldT> &cs)
	{
		libff::enter_block("Call to r1cs_convol_to_qap_instance_map");

		//const std::shared_ptr<libfqfft::evaluation_domain<FieldT> > domain = libfqfft::get_evaluation_domain<FieldT>(cs.num_constraints() + cs.num_inputs() + 1);
		const std::shared_ptr<libfqfft::evaluation_domain<FieldT> > domain = libfqfft::get_evaluation_domain<FieldT>(cs.num_constraints() + cs.num_inputs() + 1 + (cs.num_convol_outputs())*(cs.num_convol()));

		std::vector<std::map<size_t, FieldT> > A_in_Lagrange_basis(cs.num_variables()+1);
		std::vector<std::map<size_t, FieldT> > B_in_Lagrange_basis(cs.num_variables()+1);
		std::vector<std::map<size_t, FieldT> > C_in_Lagrange_basis(cs.num_variables()+1);

		libff::enter_block("Compute polynomials A, B, C in Lagrange basis");
		/**
		 * add and process the constraints
		 *     input_i * 0 = 0
		 // to ensure soundness of input consistency
		 
		for (size_t i = 0; i <= cs.num_inputs(); ++i)
		{
			A_in_Lagrange_basis[i][cs.num_constraints() + i] = FieldT::one();
		}


		size_t conv_index_a = 0;
		size_t conv_index_b = 0;
		size_t conv_index_c = 0;

		// process all other constraints 
		for (size_t i = 0; i < cs.num_constraints(); ++i)
		{
			for (size_t j = 0; j < cs.constraints[i].a.terms.size(); ++j)
			{
				A_in_Lagrange_basis[cs.constraints[i].a.terms[j].index][i] +=
					cs.constraints[i].a.terms[j].coeff;
			}

			for (size_t j = 0; j < cs.constraints[i].b.terms.size(); ++j)
			{
				B_in_Lagrange_basis[cs.constraints[i].b.terms[j].index][i] +=
					cs.constraints[i].b.terms[j].coeff;
			}

			for (size_t j = 0; j < cs.constraints[i].c.terms.size(); ++j)
			{
				C_in_Lagrange_basis[cs.constraints[i].c.terms[j].index][i] +=
					cs.constraints[i].c.terms[j].coeff;
			}


			for(size_t j=0;j<cs.constraints[i].a1.terms.size();j++){
				///TODO change (j+1) to safe value like prime
				if(j==0) conv_index_a ++;
				for(size_t k=0;k<cs.num_convol_outputs();k++){
					A_in_Lagrange_basis[cs.constraints[i].a1.terms[j].index][i] +=
						(FieldT(j+1)^cs.constraints[i].a1.terms[j].coeff.as_ulong());
				}
			}
			for(size_t j=0;j<cs.constraints[i].b1.terms.size();j++){
				///TODO change (j+1) to safe value like prime
				if(j==0) conv_index_b ++;
				for(size_t k=0;k<cs.num_convol_outputs();k++){
					B_in_Lagrange_basis[cs.constraints[i].b1.terms[j].index][i] +=
						(FieldT(j+1)^cs.constraints[i].b1.terms[j].coeff.as_ulong());
				}
			}

			for(size_t j=0;j<cs.constraints[i].c1.terms.size();j++){
				///TODO change (j+1) to safe value like prime
				if(j==0) conv_index_c ++;
				for(size_t k=0;k<cs.num_convol_outputs();k++){
					C_in_Lagrange_basis[cs.constraints[i].c1.terms[j].index][i] +=
						(FieldT(j+1)^cs.constraints[i].c1.terms[j].coeff.as_ulong());
				}
			}
		}
		libff::leave_block("Compute polynomials A, B, C in Lagrange basis");

		libff::leave_block("Call to r1cs_convol_to_qap_instance_map");

		return qap_instance<FieldT>(domain,
				cs.num_variables(),
				domain->m,
				cs.num_inputs(),
				std::move(A_in_Lagrange_basis),
				std::move(B_in_Lagrange_basis),
				std::move(C_in_Lagrange_basis));
	}
	*/
	/**
	 * Instance map for the R1CS-to-QAP reduction followed by evaluation of the resulting QAP instance.
	 *
	 * Namely, given a R1CS constraint system cs and a field element t, construct
	 * a QAP instance (evaluated at t) for which:
	 *   At := (A_0(t),A_1(t),...,A_m(t))
	 *   Bt := (B_0(t),B_1(t),...,B_m(t))
	 *   Ct := (C_0(t),C_1(t),...,C_m(t))
	 *   Ht := (1,t,t^2,...,t^n)
	 *   Zt := Z(t) = "vanishing polynomial of a certain set S, evaluated at t"
	 * where
	 *   m = number of variables of the QAP
	 *   n = degree of the QAP
	 */
	/*
	template<typename FieldT>
		qap_instance_evaluation<FieldT> r1cs_to_qap_instance_map_with_evaluation(const r1cs_constraint_convol_system<FieldT> &cs,
				const FieldT &t)
		{



			libff::enter_block("Call to r1cs_convol_to_qap_instance_map_with_evaluation");

			//const std::shared_ptr<libfqfft::evaluation_domain<FieldT> > domain = libfqfft::get_evaluation_domain<FieldT>(cs.num_constraints() + cs.num_inputs() + 1);
			const std::shared_ptr<libfqfft::evaluation_domain<FieldT> > domain = libfqfft::get_evaluation_domain<FieldT>(cs.num_constraints() + cs.num_inputs() + 1 + (cs.num_convol_outputs())*(cs.num_convol()));
			std::cout<<"degree m = "<<domain->m<<"\n";
			std::vector<FieldT> At, Bt, Ct, Ht;

			At.resize(cs.num_variables()+1, FieldT::zero());
			Bt.resize(cs.num_variables()+1, FieldT::zero());
			Ct.resize(cs.num_variables()+1, FieldT::zero());
			Ht.reserve(domain->m+1);

			const FieldT Zt = domain->compute_vanishing_polynomial(t);

			libff::enter_block("Compute evaluations of A, B, C, H at t");
			const std::vector<FieldT> u = domain->evaluate_all_lagrange_polynomials(t);
			/**
			 * add and process the constraints
			 *     input_i * 0 = 0
			 * to ensure soundness of input consistency
			 */
			/*
			   for(size_t j=0;j<cs.num_variables();j++){
			   for(size_t i=0;i<cs.num_constraints();i++){
			   if(i==0) std::cout<<j<<"\t";
			   std::cout<<cs.constraints[i].a.terms[j].coeff.as_ulong()<<"\t";
			   }
			   std::cout<<std::endl;
			   }
			 
			for (size_t i = 0; i <= cs.num_inputs(); ++i)
			{
				At[i] = u[cs.num_constraints() + i];
				//std::cout<<i<<", "<<cs.num_constraints()+i<<"\t";
			}
			//std::cout<<std::endl;

			size_t conv_index_a = 0;
			size_t conv_index_b = 0;
			size_t conv_index_c = 0;


			/* process all other constraints 
			for (size_t i = 0; i < cs.num_constraints(); ++i)
			{
				//std::cout<<"At ";
				for (size_t j = 0; j < cs.constraints[i].a.terms.size(); ++j)
				{

					At[cs.constraints[i].a.terms[j].index] +=
						u[i]*cs.constraints[i].a.terms[j].coeff;
					// std::cout<<"( "<<i<<", "<<j<<"), const a term index"<<cs.constraints[i].a.terms[j].index<<"\t";
				}
				//std::cout<<std::endl;

				for (size_t j = 0; j < cs.constraints[i].b.terms.size(); ++j)
				{
					Bt[cs.constraints[i].b.terms[j].index] +=
						u[i]*cs.constraints[i].b.terms[j].coeff;
				}

				for (size_t j = 0; j < cs.constraints[i].c.terms.size(); ++j)
				{
					Ct[cs.constraints[i].c.terms[j].index] +=
						u[i]*cs.constraints[i].c.terms[j].coeff;
				}

				for(size_t j=0;j<cs.constraints[i].a1.terms.size();j++){
					///TODO change (j+1) to safe value like prime
					FieldT temp = FieldT::one();
					if(j==0) conv_index_a ++;
					for(size_t k=0;k<cs.num_convol_outputs();k++){

						At[cs.constraints[i].a1.terms[j].index] +=
							u[(cs.num_inputs()+1+cs.num_constraints()) + (cs.num_convol_outputs()) *(conv_index_a-1) + k ] * temp;//(FieldT(k+1)^cs.constraints[i].c1.terms[j].coeff.as_ulong());
						temp *= FieldT(k+1);
							//u[cs.num_inputs()+1 + (cs.num_constraints()) + (cs.num_convol_outputs())*(conv_index_a-1) + k ] * (FieldT(k+1)^cs.constraints[i].a1.terms[j].coeff.as_ulong());
						/*
						std::cout<<"At["<<(cs.constraints[i].a1.terms[j].index)<<
							"] = u["<<(cs.num_inputs()+1+cs.num_constraints())+(cs.num_convol_outputs())*(conv_index_a-1)+k<<
							"]*("<<j+1<<")^"<<cs.constraints[i].a1.terms[j].coeff.as_ulong()<<"\n";
						
					}
				}
				for(size_t j=0;j<cs.constraints[i].b1.terms.size();j++){
					///TODO change (j+1) to safe value like prime
					FieldT temp = FieldT::one();
					if(j==0) conv_index_b ++;
					for(size_t k=0;k<cs.num_convol_outputs();k++){
						Bt[cs.constraints[i].b1.terms[j].index] +=
							u[(cs.num_inputs()+1+cs.num_constraints()) + (cs.num_convol_outputs()) *(conv_index_b-1) + k ] * temp;//(FieldT(k+1)^cs.constraints[i].c1.terms[j].coeff.as_ulong());
						temp *= FieldT(k+1);
						/*
						std::cout<<"Bt["<<(cs.constraints[i].b1.terms[j].index)<<
							"] = u["<<(cs.num_inputs()+1+cs.num_constraints())+(cs.num_convol_outputs())*(conv_index_b-1)+k<<
							"]*("<<j+1<<")^"<<cs.constraints[i].b1.terms[j].coeff.as_ulong()<<"\n";
						
					}
				}

				for(size_t j=0;j<cs.constraints[i].c1.terms.size();j++){
					///TODO change (j+1) to safe value like prime
					FieldT temp = FieldT::one();
					if(j==0) conv_index_c ++;
					for(size_t k=0;k<cs.num_convol_outputs();k++){
						Ct[cs.constraints[i].c1.terms[j].index] +=
							u[(cs.num_inputs()+1+cs.num_constraints()) + (cs.num_convol_outputs()) *(conv_index_c-1) + k ] * temp;//(FieldT(k+1)^cs.constraints[i].c1.terms[j].coeff.as_ulong());
						temp *= FieldT(k+1);
						/*
						std::cout<<"Ct["<<(cs.constraints[i].c1.terms[j].index)<<
							"] = u["<<(cs.num_inputs()+1+cs.num_constraints())+(cs.num_convol_outputs())*(conv_index_c-1)+k<<
							"]*("<<j+1<<")^"<<cs.constraints[i].c1.terms[j].coeff.as_ulong()<<"\n";
						
					}
				}
			}

			FieldT ti = FieldT::one();
			for (size_t i = 0; i < domain->m+1; ++i)
			{
				Ht.emplace_back(ti);
				ti *= t;
			}
			libff::leave_block("Compute evaluations of A, B, C, H at t");

			libff::leave_block("Call to r1cs_convol_to_qap_instance_map_with_evaluation");

			return qap_instance_evaluation<FieldT>(domain,
					cs.num_variables(),
					domain->m,
					cs.num_inputs(),
					t,
					std::move(At),
					std::move(Bt),
					std::move(Ct),
					std::move(Ht),
					Zt);
		}
		*/

	/**
	 * Witness map for the R1CS-to-QAP reduction.
	 *
	 * The witness map takes zero knowledge into account when d1,d2,d3 are random.
	 *
	 * More precisely, compute the coefficients
	 *     h_0,h_1,...,h_n
	 * of the polynomial
	 *     H(z) := (A(z)*B(z)-C(z))/Z(z)
	 * where
	 *   A(z) := A_0(z) + \sum_{k=1}^{m} w_k A_k(z) + d1 * Z(z)
	 *   B(z) := B_0(z) + \sum_{k=1}^{m} w_k B_k(z) + d2 * Z(z)
	 *   C(z) := C_0(z) + \sum_{k=1}^{m} w_k C_k(z) + d3 * Z(z)
	 *   Z(z) := "vanishing polynomial of set S"
	 * and
	 *   m = number of variables of the QAP
	 *   n = degree of the QAP
	 *
	 * This is done as follows:
	 *  (1) compute evaluations of A,B,C on S = {sigma_1,...,sigma_n}
	 *  (2) compute coefficients of A,B,C
	 *  (3) compute evaluations of A,B,C on T = "coset of S"
	 *  (4) compute evaluation of H on T
	 *  (5) compute coefficients of H
	 *  (6) patch H to account for d1,d2,d3 (i.e., add coefficients of the polynomial (A d2 + B d1 - d3) + d1*d2*Z )
	 *
	 * The code below is not as simple as the above high-level description due to
	 * some reshuffling to save space.
	 */
	/*
	template<typename FieldT>
		qap_witness<FieldT> r1cs_to_qap_witness_map(const r1cs_constraint_convol_system<FieldT> &cs,
				const r1cs_primary_input<FieldT> &primary_input,
				const r1cs_auxiliary_input<FieldT> &auxiliary_input,
				const FieldT &d1,
				const FieldT &d2,
				const FieldT &d3)
		{
			libff::enter_block("Call to r1cs_convol_to_qap_witness_map");

			/* sanity check 
			assert(cs.is_satisfied(primary_input, auxiliary_input));

			const std::shared_ptr<libfqfft::evaluation_domain<FieldT> > domain = libfqfft::get_evaluation_domain<FieldT>(cs.num_constraints() + cs.num_inputs() + 1 + (cs.num_convol_outputs())*(cs.num_convol()));

			r1cs_variable_assignment<FieldT> full_variable_assignment = primary_input;
			full_variable_assignment.insert(full_variable_assignment.end(), auxiliary_input.begin(), auxiliary_input.end());


			libff::enter_block("Compute evaluation of polynomials A, B on set S");
			std::vector<FieldT> aA(domain->m, FieldT::zero()), aB(domain->m, FieldT::zero());

			std::cout<<"num inputs : "<<cs.num_inputs()<<" num constraints : "<< cs.num_constraints()<<"\n";
			/* account for the additional constraints input_i * 0 = 0 
			for (size_t i = 0; i <= cs.num_inputs(); ++i)
			{
				aA[i+cs.num_constraints()] = (i > 0 ? full_variable_assignment[i-1] : FieldT::one());
			}
			/* account for all other constraints 
			for (size_t i = 0; i < cs.num_constraints(); ++i)
			{
				aA[i] += cs.constraints[i].a.evaluate(full_variable_assignment);
				aB[i] += cs.constraints[i].b.evaluate(full_variable_assignment);
			}

			size_t conv_index = 0;
			size_t conv_index2 = 0;
			for( size_t i=0;i<cs.num_constraints();i++){
				FieldT acc = FieldT::zero();
				bool flag = false;
				for(auto &lt : cs.constraints[i].a1){
					if(!flag){ 
						conv_index++;
						flag = true;
					}
					FieldT temp = FieldT::one();
					for(size_t j=1;j<=cs.num_convol_outputs();j++){
						//if(lt.idex ==0) acc += (FieldT::one()*cs.conv_num_output()) * lt.coeff; //there is no first one in conv constraints
						acc = full_variable_assignment[lt.index-1] * temp;//(FieldT(j)^lt.coeff.as_ulong());
						temp *= FieldT(j);
						//std::cout<<"acc : "<<acc.as_ulong()<<" var["<<lt.index-1<<"]*("<<j<<"^"<<lt.coeff.as_ulong()<<")\n";
						aA[(j)+(conv_index-1)*cs.num_convol_outputs() + cs.num_constraints() + cs.num_inputs()] += acc;
						//std::cout<<"aA["<<(j-1)+(conv_index-1)*cs.num_convol_outputs()+cs.num_constraints()+cs.num_inputs()<<"] = acc\n";
					}
					//if(acc != FieldT::zero()){
					//}
				}
				/*
				for(size_t j=1;j<=cs.num_convol_outputs();j++){
					std::cout<<"aA["<<(j)+cs.num_constraints()+cs.num_inputs()<<"] ="<<
						aA[(j) + cs.num_constraints() + cs.num_inputs()].as_ulong() <<"\n";
				}
				
				acc = FieldT::zero();
				flag = false;
				for(auto &lt : cs.constraints[i].b1){
					if(!flag){ 
						conv_index2++;
						flag = true;
					}
					FieldT temp = FieldT::one();
					for(size_t j=1;j<=cs.num_convol_outputs();j++){
						acc = full_variable_assignment[lt.index-1] * temp;//(FieldT(j)^lt.coeff.as_ulong());
						temp *= FieldT(j);
						//std::cout<<"acc : "<<acc.as_ulong()<<" var["<<lt.index-1<<"]*("<<j<<"^"<<lt.coeff.as_ulong()<<")\n";
						aB[(conv_index2-1)*cs.num_convol_outputs() +(j) + cs.num_constraints() + cs.num_inputs()] += acc;
						//std::cout<<"aB["<<(conv_index2-1)*cs.num_convol_outputs()+(j-1)+cs.num_constraints()+cs.num_inputs()<<"] = acc\n";
					}
					//aB[i*cs.num_convol() + j + cs.num_constraints() + cs.num_inputs()] += acc;
				}
				/*
				for(size_t j=1;j<=cs.num_convol_outputs();j++){
					std::cout<<"aB["<< +(j)+cs.num_constraints()+cs.num_inputs()<<"] ="<<
						aB[(j) + cs.num_constraints() + cs.num_inputs()].as_ulong() <<"\n";
				}
				
			}
			libff::leave_block("Compute evaluation of polynomials A, B on set S");

			libff::enter_block("Compute coefficients of polynomial A");
			domain->iFFT(aA);
			libff::leave_block("Compute coefficients of polynomial A");

			libff::enter_block("Compute coefficients of polynomial B");
			domain->iFFT(aB);
			libff::leave_block("Compute coefficients of polynomial B");

			libff::enter_block("Compute ZK-patch");
			std::vector<FieldT> coefficients_for_H(domain->m+1, FieldT::zero());
#ifdef MULTICORE
#pragma omp parallel for
#endif
			// add coefficients of the polynomial (d2*A + d1*B - d3) + d1*d2*Z 
			for (size_t i = 0; i < domain->m; ++i)
			{
				coefficients_for_H[i] = d2*aA[i] + d1*aB[i];
			}
			coefficients_for_H[0] -= d3;
			domain->add_poly_Z(d1*d2, coefficients_for_H);
			libff::leave_block("Compute ZK-patch");

			libff::enter_block("Compute evaluation of polynomial A on set T");
			domain->cosetFFT(aA, FieldT::multiplicative_generator);
			libff::leave_block("Compute evaluation of polynomial A on set T");

			libff::enter_block("Compute evaluation of polynomial B on set T");
			domain->cosetFFT(aB, FieldT::multiplicative_generator);
			libff::leave_block("Compute evaluation of polynomial B on set T");

			libff::enter_block("Compute evaluation of polynomial H on set T");
			std::vector<FieldT> &H_tmp = aA; // can overwrite aA because it is not used later
#ifdef MULTICORE
#pragma omp parallel for
#endif
			for (size_t i = 0; i < domain->m; ++i)
			{
				H_tmp[i] = aA[i]*aB[i];
			}
			std::vector<FieldT>().swap(aB); // destroy aB

			libff::enter_block("Compute evaluation of polynomial C on set S");
			std::vector<FieldT> aC(domain->m, FieldT::zero());
			for (size_t i = 0; i < cs.num_constraints(); ++i)
			{
				aC[i] += cs.constraints[i].c.evaluate(full_variable_assignment);
			}

			conv_index = 0;
			for( size_t i=0;i<cs.num_constraints();i++){
				FieldT acc = FieldT::zero();
				bool flag = false;
				for(auto &lt : cs.constraints[i].c1){
					if(!flag){
						conv_index++;
						flag = true;
					}
					FieldT temp = FieldT::one();
					for(size_t j=1;j<=cs.num_convol_outputs();j++){
						acc = full_variable_assignment[lt.index-1] * temp;//(FieldT(j)^lt.coeff.as_ulong());
						temp *= FieldT(j);
						aC[(conv_index-1)*cs.num_convol_outputs()+ (j) + cs.num_constraints() + cs.num_inputs()] += acc;
						//std::cout<<"acc : "<<acc.as_ulong()<<" var["<<lt.index-1<<"]*("<<j<<"^"<<lt.coeff.as_ulong()<<")\n";
						//std::cout<<"aC["<<(conv_index-1)*cs.num_convol_outputs() +(j-1)+cs.num_constraints()+cs.num_inputs()<<"] = acc\n";
					}
				}
				/*
				//for debug
				for(size_t j=1;j<=cs.num_convol_outputs();j++){
					std::cout<<"aC["<<(j)+cs.num_constraints()+cs.num_inputs()<<"] ="<<
						aC[(j) + cs.num_constraints() + cs.num_inputs()].as_ulong() <<"\n";
				}
				/

			}
			libff::leave_block("Compute evaluation of polynomial C on set S");

			libff::enter_block("Compute coefficients of polynomial C");
			domain->iFFT(aC);
			libff::leave_block("Compute coefficients of polynomial C");

			libff::enter_block("Compute evaluation of polynomial C on set T");
			domain->cosetFFT(aC, FieldT::multiplicative_generator);
			libff::leave_block("Compute evaluation of polynomial C on set T");

#ifdef MULTICORE
#pragma omp parallel for
#endif
			for (size_t i = 0; i < domain->m; ++i)
			{
				H_tmp[i] = (H_tmp[i]-aC[i]);
			}

			libff::enter_block("Divide by Z on set T");
			domain->divide_by_Z_on_coset(H_tmp);
			libff::leave_block("Divide by Z on set T");

			libff::leave_block("Compute evaluation of polynomial H on set T");

			libff::enter_block("Compute coefficients of polynomial H");
			domain->icosetFFT(H_tmp, FieldT::multiplicative_generator);
			libff::leave_block("Compute coefficients of polynomial H");

			libff::enter_block("Compute sum of H and ZK-patch");
#ifdef MULTICORE
#pragma omp parallel for
#endif
			for (size_t i = 0; i < domain->m; ++i)
			{
				coefficients_for_H[i] += H_tmp[i];
			}
			libff::leave_block("Compute sum of H and ZK-patch");

			libff::leave_block("Call to r1cs_convol_to_qap_witness_map");

			return qap_witness<FieldT>(cs.num_variables(),
					domain->m,
					cs.num_inputs(),
					d1,
					d2,
					d3,
					full_variable_assignment,
					std::move(coefficients_for_H));
		}
*/
} // libsnark

#endif // R1CS_TO_QP_TCC_
